// Generated by CoffeeScript 2.6.1
//###########################################################
var ORDER, createKeyObject, createKeyObjectBytes, createKeyObjectHex, crypto, hashToScalar, mod;

import * as noble from "@noble/ed25519";

import * as tbut from "thingy-byte-utils";

crypto = window.crypto.subtle;

ORDER = BigInt(2) ** BigInt(252) + BigInt('27742317777372353535851937790883648493');

//###########################################################
//region internalFunctions
hashToScalar = function(byteBuffer) {
  var bigInt, relevant;
  relevant = new Uint8Array(byteBuffer.slice(0, 32));
  relevant[0] &= 248;
  relevant[31] &= 127;
  relevant[31] |= 64;
  bigInt = tbut.bytesToBigInt(relevant);
  return mod(bigInt);
};

mod = function(a, b = ORDER) {
  var result;
  result = a % b;
  if (result >= 0n) {
    return result;
  } else {
    return result + b;
  }
};

//###########################################################
createKeyObject = async function(keyHex) {
  var keyBytes;
  keyBytes = tbut.hexToBytes(keyHex);
  return (await crypto.importKey("raw", keyBytes, {
    name: "AES-CBC"
  }, false, ["decrypt", "encrypt"]));
};

createKeyObjectHex = createKeyObject;

createKeyObjectBytes = async function(keyBytes) {
  return (await crypto.importKey("raw", keyBytes, {
    name: "AES-CBC"
  }, false, ["decrypt", "encrypt"]));
};

//endregion

//###########################################################
//region exposedStuff

//###########################################################
//region shas

//###########################################################
// Hex Version
export var sha256 = async function(content) {
  var contentBytes, hashBytes;
  if ((typeof content) === "string") {
    contentBytes = tbut.utf8ToBytes(content);
  } else {
    contentBytes = content;
  }
  hashBytes = (await crypto.digest("SHA-256", contentBytes));
  return tbut.bytesToHex(hashBytes);
};

export var sha512 = async function(content) {
  var contentBytes, hashBytes;
  if ((typeof content) === "string") {
    contentBytes = tbut.utf8ToBytes(content);
  } else {
    contentBytes = content;
  }
  hashBytes = (await crypto.digest("SHA-512", contentBytes));
  return tbut.bytesToHex(hashBytes);
};

export var sha256Hex = sha256;

export var sha512Hex = sha512;

//###########################################################
// Byte Version
export var sha256Bytes = async function(content) {
  var contentBytes;
  if ((typeof content) === "string") {
    contentBytes = tbut.utf8ToBytes(content);
  } else {
    contentBytes = content;
  }
  return (await crypto.digest("SHA-256", contentBytes));
};

export var sha512Bytes = async function(content) {
  var contentBytes;
  if ((typeof content) === "string") {
    contentBytes = tbut.utf8ToBytes(content);
  } else {
    contentBytes = content;
  }
  return (await crypto.digest("SHA-512", contentBytes));
};

//endregion

//###########################################################
//region keys

//###########################################################
// Hex Version
export var createKeyPair = async function() {
  var publicKey, publicKeyHex, secretKey, secretKeyHex;
  secretKey = noble.utils.randomPrivateKey();
  publicKey = (await noble.getPublicKey(secretKey));
  secretKeyHex = tbut.bytesToHex(secretKey);
  publicKeyHex = tbut.bytesToHex(publicKey);
  return {secretKeyHex, publicKeyHex};
};

export var createSymKey = function() {
  var keyAndIV;
  keyAndIV = new Uint8Array(48);
  window.crypto.getRandomValues(keyAndIV);
  return tbut.bytesToHex(keyAndIV);
};

export var createKeyPairHex = createKeyPair;

export var createSymKeyHex = createSymKey;

//###########################################################
// Byte Version
export var createKeyPairBytes = async function() {
  var publicKeyBytes, secretKeyBytes;
  secretKeyBytes = noble.utils.randomPrivateKey();
  publicKeyBytes = (await noble.getPublicKey(secretKeyBytes));
  return {secretKeyBytes, publicKeyBytes};
};

export var createSymKeyBytes = function() {
  var keyAndIV;
  keyAndIV = new Uint8Array(48);
  window.crypto.getRandomValues(keyAndIV);
  return keyAndIV;
};

//endregion

//###########################################################
//region signatures

//###########################################################
// Hex Version
export var createSignature = async function(content, signingKeyHex) {
  var hashHex, signature;
  hashHex = (await sha256Hex(content));
  signature = (await noble.sign(hashHex, signingKeyHex));
  return tbut.bytesToHex(signature);
};

export var verify = async function(sigHex, keyHex, content) {
  var hashHex;
  hashHex = (await sha256Hex(content));
  return (await noble.verify(sigHex, hashHex, keyHex));
};

export var createSignatureHex = createSignature;

export var verifyHex = verify;

//###########################################################
// Byte Version
export var createSignatureBytes = async function(content, signingKeyBytes) {
  var hashBytes;
  hashBytes = (await sha256Bytes(content));
  return (await noble.sign(hashBytes, signingKeyBytes));
};

export var verifyBytes = async function(sigBytes, keyBytes, content) {
  var hashBytes;
  hashBytes = (await sha256Bytes(content));
  return (await noble.verify(sigBytes, hashBytes, keyBytes));
};

//endregion

//###########################################################
//region symmetric encryption

//###########################################################
// Hex Version
export var symmetricEncrypt = async function(content, keyHex) {
  var aesKeyHex, algorithm, contentBuffer, gibbrishBuffer, ivBuffer, ivHex, keyObjHex;
  ivHex = keyHex.substring(0, 32);
  aesKeyHex = keyHex.substring(32, 96);
  ivBuffer = tbut.hexToBytes(ivHex);
  contentBuffer = tbut.utf8ToBytes(content);
  keyObjHex = (await createKeyObjectHex(aesKeyHex));
  algorithm = {
    name: "AES-CBC",
    iv: ivBuffer
  };
  gibbrishBuffer = (await crypto.encrypt(algorithm, keyObjHex, contentBuffer));
  return tbut.bytesToHex(gibbrishBuffer);
};

export var symmetricDecrypt = async function(gibbrishHex, keyHex) {
  var aesKeyHex, algorithm, contentBuffer, gibbrishBuffer, ivBuffer, ivHex, keyObjHex;
  ivHex = keyHex.substring(0, 32);
  aesKeyHex = keyHex.substring(32, 96);
  ivBuffer = tbut.hexToBytes(ivHex);
  gibbrishBuffer = tbut.hexToBytes(gibbrishHex);
  keyObjHex = (await createKeyObjectHex(aesKeyHex));
  algorithm = {
    name: "AES-CBC",
    iv: ivBuffer
  };
  contentBuffer = (await crypto.decrypt(algorithm, keyObjHex, gibbrishBuffer));
  return tbut.bytesToUtf8(contentBuffer);
};

export var symmetricEncryptHex = symmetricEncrypt;

export var symmetricDecryptHex = symmetricDecrypt;

//###########################################################
// Byte Version
export var symmetricEncryptBytes = async function(content, keyBytes) {
  var aesKeyBytes, algorithm, contentBytes, gibbrishBytes, ivBytes, keyObjBytes;
  // ivHex = keyHex.substring(0, 32)
  ivBytes = new Uint8Array(keyBytes.buffer, 0, 16);
  // aesKeyHex = keyHex.substring(32,96)
  aesKeyBytes = new Uint8Array(keyBytes.buffer, 16, 32);
  contentBytes = tbut.utf8ToBytes(content);
  keyObjBytes = (await createKeyObjectBytes(aesKeyBytes));
  algorithm = {
    name: "AES-CBC",
    iv: ivBytes
  };
  gibbrishBytes = (await crypto.encrypt(algorithm, keyObjBytes, contentBytes));
  return gibbrishBytes;
};

export var symmetricDecryptBytes = async function(gibbrishBytes, keyBytes) {
  var aesKeyBytes, algorithm, contentBytes, ivBytes, keyObjBytes;
  ivBytes = new Uint8Array(keyBytes.buffer, 0, 16);
  aesKeyBytes = new Uint8Array(keyBytes.buffer, 16, 32);
  // ivHex = keyHex.substring(0, 32)
  // aesKeyHex = keyHex.substring(32,96)
  keyObjBytes = (await createKeyObjectHex(aesKeyBytes));
  algorithm = {
    name: "AES-CBC",
    iv: ivBytes
  };
  contentBytes = (await crypto.decrypt(algorithm, keyObjBytes, gibbrishBytes));
  return tbut.bytesToUtf8(contentBytes);
};

//endregion

//###########################################################
//region asymmetric encryption

//###########################################################
// Hex Version
export var asymmetricEncryptOld = async function(content, publicKeyHex) {
  var ABytes, B, BHex, encryptedContentHex, gibbrish, lB, lBigInt, nBytes, nHex, referencePointHex, symkey;
  // a = Private Key
  // k = sha512(a) -> hashToScalar
  // G = basePoint
  // B = kG = Public Key
  B = noble.Point.fromHex(publicKeyHex);
  BHex = publicKeyHex;
  // log "BHex: " + BHex

  // n = new one-time secret (generated on sever and forgotten about)
  // l = sha512(n) -> hashToScalar
  // lB = lkG = shared secret
  // key = sha512(lBHex)
  // X = symmetricEncrypt(content, key)
  // A = lG = one time public reference point
  // {A,X} = data to be stored for B

  // n = one-time secret
  nBytes = noble.utils.randomPrivateKey();
  nHex = tbut.bytesToHex(nBytes);
  lBigInt = hashToScalar((await sha512Bytes(nBytes)));
  
  //A one time public key = reference Point
  ABytes = (await noble.getPublicKey(nHex));
  lB = (await B.multiply(lBigInt));
  symkey = (await sha512Hex(lB.toHex()));
  gibbrish = (await symmetricEncryptHex(content, symkey));
  referencePointHex = tbut.bytesToHex(ABytes);
  encryptedContentHex = gibbrish;
  return {referencePointHex, encryptedContentHex};
};

export var asymmetricDecryptOld = async function(secrets, privateKeyHex) {
  var A, AHex, aBytes, content, gibbrishHex, kA, kBigInt, symkey;
  AHex = secrets.referencePointHex || secrets.referencePoint;
  gibbrishHex = secrets.encryptedContentHex || secrets.encryptedContent;
  if ((AHex == null) || (gibbrishHex == null)) {
    throw new Error("Invalid secrets Object!");
  }
  // a = Private Key
  // k = sha512(a) -> hashToScalar
  // G = basePoint
  // B = kG = Public Key
  aBytes = tbut.hexToBytes(privateKeyHex);
  kBigInt = hashToScalar((await sha512Bytes(aBytes)));
  
  // {A,X} = secrets
  // A = lG = one time public reference point 
  // klG = lB = kA = shared secret
  // key = sha512(kAHex)
  // content = symmetricDecrypt(X, key)
  A = noble.Point.fromHex(AHex);
  kA = (await A.multiply(kBigInt));
  symkey = (await sha512Hex(kA.toHex()));
  content = (await symmetricDecryptHex(gibbrishHex, symkey));
  return content;
};

export var asymmetricEncrypt = async function(content, publicKeyHex) {
  var A, encryptedContentHex, gibbrish, lB, nBytes, referencePointHex, symkey;
  nBytes = noble.utils.randomPrivateKey();
  A = (await noble.getPublicKey(nBytes));
  lB = (await noble.getSharedSecret(nBytes, publicKeyHex));
  symkey = (await sha512Bytes(lB));
  gibbrish = (await symmetricEncryptBytes(content, symkey));
  referencePointHex = tbut.bytesToHex(A);
  encryptedContentHex = tbut.bytesToHex(gibbrish);
  return {referencePointHex, encryptedContentHex};
};

export var asymmetricDecrypt = async function(secrets, privateKeyHex) {
  var AHex, content, gibbrishBytes, gibbrishHex, kA, symkey;
  AHex = secrets.referencePointHex || secrets.referencePoint;
  gibbrishHex = secrets.encryptedContentHex || secrets.encryptedContent;
  if ((AHex == null) || (gibbrishHex == null)) {
    throw new Error("Invalid secrets Object!");
  }
  kA = (await noble.getSharedSecret(privateKeyHex, AHex));
  symkey = (await sha512Bytes(kA));
  gibbrishBytes = tbut.hexToBytes(gibbrishHex);
  content = (await symmetricDecryptBytes(gibbrishBytes, symkey));
  return content;
};

export var asymmetricEncryptHex = asymmetricEncrypt;

export var asymmetricDecryptHex = asymmetricDecrypt;

//###########################################################
// Byte Version
export var asymmetricEncryptBytes = async function(content, publicKeyBytes) {
  var ABytes, encryptedContentBytes, gibbrishBytes, lB, nBytes, referencePointBytes, symkeyBytes;
  nBytes = noble.utils.randomPrivateKey();
  ABytes = (await noble.getPublicKey(nBytes));
  lB = (await noble.getSharedSecret(nBytes, publicKeyBytes));
  symkeyBytes = (await sha512Bytes(lB));
  gibbrishBytes = (await symmetricEncryptBytes(content, symkeyBytes));
  referencePointBytes = ABytes;
  encryptedContentBytes = gibbrishBytes;
  return {referencePointBytes, encryptedContentBytes};
};

export var asymmetricDecryptBytes = async function(secrets, privateKeyBytes) {
  var ABytes, content, gibbrishBytes, kABytes, symkeyBytes;
  ABytes = secrets.referencePointBytes || secrets.referencePoint;
  gibbrishBytes = secrets.encryptedContentBytes || secrets.encryptedContent;
  if ((ABytes == null) || (gibbrishBytes == null)) {
    throw new Error("Invalid secrets Object!");
  }
  kABytes = (await noble.getSharedSecret(privateKeyBytes, ABytes));
  symkeyBytes = (await sha512Bytes(kABytes));
  content = (await symmetricDecryptBytes(gibbrishBytes, symkeyBytes));
  return content;
};

//endregion

//###########################################################
//region salts
export var createRandomLengthSalt = function() {
  var byte, bytes, i, j, len;
  bytes = new Uint8Array(512);
  while (true) {
    window.crypto.getRandomValues(bytes);
    for (i = j = 0, len = bytes.length; j < len; i = ++j) {
      byte = bytes[i];
      if (byte === 0) {
        return tbut.bytesToUtf8(bytes.slice(0, i + 1));
      }
    }
  }
};

export var removeSalt = function(content) {
  var char, i, j, len;
  for (i = j = 0, len = content.length; j < len; i = ++j) {
    char = content[i];
    if (char === "\0") {
      return content.slice(i + 1);
    }
  }
  throw new Error("No Salt termination found!");
};


//endregion

//endregion
